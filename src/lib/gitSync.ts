
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import prisma from '@/lib/prisma';

const execAsync = promisify(exec);

interface Todo {
  id: string;
  title: string;
  description: string | null;
  priority: string;
  status: string;
  category: string | null;
  tags: string | null;
  createdAt: Date;
  updatedAt: Date;
  completedAt: Date | null;
  documents?: Array<{
    id: string;
    filename: string;
    filepath: string;
  }>;
}

/**
 * Format a TODO item as markdown
 */
function formatTodoForMarkdown(todo: Todo): string {
  const lines: string[] = [];
  
  lines.push(`### ${todo.title}`);
  lines.push('');
  lines.push(`- **ID**: \`${todo.id}\``);
  lines.push(`- **Priority**: ${todo.priority}`);
  lines.push(`- **Status**: ${todo.status}`);
  
  if (todo.category) {
    lines.push(`- **Category**: ${todo.category}`);
  }
  
  if (todo.description) {
    lines.push(`- **Description**: ${todo.description}`);
  }
  
  if (todo.tags) {
    try {
      const tags = JSON.parse(todo.tags);
      if (Array.isArray(tags) && tags.length > 0) {
        lines.push(`- **Tags**: ${tags.join(', ')}`);
      }
    } catch (e) {
      // Ignore invalid JSON
    }
  }
  
  if (todo.documents && todo.documents.length > 0) {
    lines.push(`- **Documents**: ${todo.documents.length} file(s)`);
    todo.documents.forEach(doc => {
      lines.push(`  - ${doc.filename}`);
    });
  }
  
  lines.push(`- **Created**: ${new Date(todo.createdAt).toLocaleString()}`);
  lines.push(`- **Updated**: ${new Date(todo.updatedAt).toLocaleString()}`);
  
  if (todo.completedAt) {
    lines.push(`- **Completed**: ${new Date(todo.completedAt).toLocaleString()}`);
  }
  
  lines.push('');
  return lines.join('\n');
}

/**
 * Generate TODO_LIST.md content from database
 */
async function generateTodoListMarkdown(): Promise<string> {
  const todos = await prisma.todo.findMany({
    include: {
      documents: true
    },
    orderBy: [
      { status: 'asc' },
      { priority: 'desc' },
      { createdAt: 'desc' }
    ]
  });
  
  const lines: string[] = [];
  
  lines.push('# TODO List');
  lines.push('');
  lines.push('> **‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT MANUALLY**');
  lines.push('> This file is automatically generated and updated by the TODO management system.');
  lines.push('> Any manual changes will be overwritten.');
  lines.push('');
  lines.push(`Last Updated: ${new Date().toLocaleString()}`);
  lines.push('');
  lines.push('---');
  lines.push('');
  
  // Group by status
  const statusGroups = {
    PLANNED: todos.filter(t => t.status === 'PLANNED'),
    IN_PROGRESS: todos.filter(t => t.status === 'IN_PROGRESS'),
    TESTING: todos.filter(t => t.status === 'TESTING'),
    COMPLETE: todos.filter(t => t.status === 'COMPLETE')
  };
  
  // PLANNED
  lines.push('## üìã Planned');
  lines.push('');
  if (statusGroups.PLANNED.length === 0) {
    lines.push('*No planned items*');
    lines.push('');
  } else {
    statusGroups.PLANNED.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  // IN_PROGRESS
  lines.push('## üöß In Progress');
  lines.push('');
  if (statusGroups.IN_PROGRESS.length === 0) {
    lines.push('*No items in progress*');
    lines.push('');
  } else {
    statusGroups.IN_PROGRESS.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  // TESTING
  lines.push('## üß™ Testing');
  lines.push('');
  if (statusGroups.TESTING.length === 0) {
    lines.push('*No items in testing*');
    lines.push('');
  } else {
    statusGroups.TESTING.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  // COMPLETE
  lines.push('## ‚úÖ Complete');
  lines.push('');
  if (statusGroups.COMPLETE.length === 0) {
    lines.push('*No completed items*');
    lines.push('');
  } else {
    statusGroups.COMPLETE.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  lines.push('---');
  lines.push('');
  lines.push(`**Total TODOs**: ${todos.length}`);
  lines.push(`- Planned: ${statusGroups.PLANNED.length}`);
  lines.push(`- In Progress: ${statusGroups.IN_PROGRESS.length}`);
  lines.push(`- Testing: ${statusGroups.TESTING.length}`);
  lines.push(`- Complete: ${statusGroups.COMPLETE.length}`);
  
  return lines.join('\n');
}

/**
 * Commit and push changes to GitHub
 */
async function commitAndPush(message: string): Promise<void> {
  const projectRoot = path.resolve(process.cwd());
  
  try {
    // Configure git if not already configured
    try {
      await execAsync('git config user.name', { cwd: projectRoot });
    } catch {
      await execAsync('git config user.name "Sports Bar TV Controller"', { cwd: projectRoot });
      await execAsync('git config user.email "system@sportsbar.local"', { cwd: projectRoot });
    }
    
    // Add TODO_LIST.md
    await execAsync('git add TODO_LIST.md', { cwd: projectRoot });
    
    // Check if there are changes to commit
    const { stdout: status } = await execAsync('git status --porcelain', { cwd: projectRoot });
    
    if (status.trim()) {
      // Commit
      await execAsync(`git commit -m "${message}"`, { cwd: projectRoot });
      
      // Push
      await execAsync('git push origin main', { cwd: projectRoot });
      
      console.log(`‚úÖ Git sync successful: ${message}`);
    } else {
      console.log('‚ÑπÔ∏è No changes to commit');
    }
  } catch (error) {
    console.error('‚ùå Git sync error:', error);
    throw error;
  }
}

/**
 * Sync TODOs to GitHub by updating TODO_LIST.md and committing
 */
export async function syncTodosToGitHub(commitMessage: string): Promise<void> {
  try {
    // Generate markdown content
    const markdown = await generateTodoListMarkdown();
    
    // Write to TODO_LIST.md
    const todoListPath = path.resolve(process.cwd(), 'TODO_LIST.md');
    await fs.writeFile(todoListPath, markdown, 'utf-8');
    
    console.log('‚úÖ TODO_LIST.md updated');
    
    // Commit and push
    await commitAndPush(commitMessage);
  } catch (error) {
    console.error('‚ùå Error syncing TODOs to GitHub:', error);
    throw error;
  }
}
