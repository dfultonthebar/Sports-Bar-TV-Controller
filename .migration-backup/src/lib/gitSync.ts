
import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import { findMany, eq, asc, desc } from '@/lib/db-helpers'
import { schema } from '@/db'

import { logger } from '@/lib/logger'
const execAsync = promisify(exec);

interface Todo {
  id: string;
  title: string;
  description: string | null;
  priority: string;
  status: string;
  category: string | null;
  tags: string | null;
  createdAt: Date;
  updatedAt: Date;
  completedAt: Date | null;
  documents?: Array<{
    id: string;
    filename: string;
    filepath: string;
  }>;
}

/**
 * Format a TODO item as markdown
 */
function formatTodoForMarkdown(todo: Todo): string {
  const lines: string[] = [];
  
  lines.push(`### ${todo.title}`);
  lines.push('');
  lines.push(`- **ID**: \`${todo.id}\``);
  lines.push(`- **Priority**: ${todo.priority}`);
  lines.push(`- **Status**: ${todo.status}`);
  
  if (todo.category) {
    lines.push(`- **Category**: ${todo.category}`);
  }
  
  if (todo.description) {
    lines.push(`- **Description**: ${todo.description}`);
  }
  
  if (todo.tags) {
    try {
      const tags = JSON.parse(todo.tags);
      if (Array.isArray(tags) && tags.length > 0) {
        lines.push(`- **Tags**: ${tags.join(', ')}`);
      }
    } catch (e) {
      // Ignore invalid JSON
    }
  }
  
  if (todo.documents && todo.documents.length > 0) {
    lines.push(`- **Documents**: ${todo.documents.length} file(s)`);
    todo.documents.forEach(doc => {
      lines.push(`  - ${doc.filename}`);
    });
  }
  
  lines.push(`- **Created**: ${new Date(todo.createdAt).toLocaleString()}`);
  lines.push(`- **Updated**: ${new Date(todo.updatedAt).toLocaleString()}`);
  
  if (todo.completedAt) {
    lines.push(`- **Completed**: ${new Date(todo.completedAt).toLocaleString()}`);
  }
  
  lines.push('');
  return lines.join('\n');
}

/**
 * Generate TODO_LIST.md content from database
 */
async function generateTodoListMarkdown(): Promise<string> {
  const todosList = await findMany('todos', {
    orderBy: [asc(schema.todos.status), desc(schema.todos.priority), desc(schema.todos.createdAt)]
  });

  // Fetch documents for each todo
  const todos = await Promise.all(
    todosList.map(async (todo) => {
      const documents = await findMany('todoDocuments', {
        where: eq(schema.todoDocuments.todoId, todo.id)
      })
      return { ...todo, documents }
    })
  );
  
  const lines: string[] = [];
  
  lines.push('# TODO List');
  lines.push('');
  lines.push('> **‚ö†Ô∏è AUTO-GENERATED FILE - DO NOT EDIT MANUALLY**');
  lines.push('> This file is automatically generated and updated by the TODO management system.');
  lines.push('> Any manual changes will be overwritten.');
  lines.push('');
  lines.push(`Last Updated: ${new Date().toLocaleString()}`);
  lines.push('');
  lines.push('---');
  lines.push('');
  
  // Group by status
  const statusGroups = {
    PLANNED: todos.filter(t => t.status === 'PLANNED'),
    IN_PROGRESS: todos.filter(t => t.status === 'IN_PROGRESS'),
    TESTING: todos.filter(t => t.status === 'TESTING'),
    COMPLETE: todos.filter(t => t.status === 'COMPLETE')
  };
  
  // PLANNED
  lines.push('## üìã Planned');
  lines.push('');
  if (statusGroups.PLANNED.length === 0) {
    lines.push('*No planned items*');
    lines.push('');
  } else {
    statusGroups.PLANNED.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  // IN_PROGRESS
  lines.push('## üöß In Progress');
  lines.push('');
  if (statusGroups.IN_PROGRESS.length === 0) {
    lines.push('*No items in progress*');
    lines.push('');
  } else {
    statusGroups.IN_PROGRESS.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  // TESTING
  lines.push('## üß™ Testing');
  lines.push('');
  if (statusGroups.TESTING.length === 0) {
    lines.push('*No items in testing*');
    lines.push('');
  } else {
    statusGroups.TESTING.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  // COMPLETE
  lines.push('## ‚úÖ Complete');
  lines.push('');
  if (statusGroups.COMPLETE.length === 0) {
    lines.push('*No completed items*');
    lines.push('');
  } else {
    statusGroups.COMPLETE.forEach(todo => {
      lines.push(formatTodoForMarkdown(todo));
    });
  }
  
  lines.push('---');
  lines.push('');
  lines.push(`**Total TODOs**: ${todos.length}`);
  lines.push(`- Planned: ${statusGroups.PLANNED.length}`);
  lines.push(`- In Progress: ${statusGroups.IN_PROGRESS.length}`);
  lines.push(`- Testing: ${statusGroups.TESTING.length}`);
  lines.push(`- Complete: ${statusGroups.COMPLETE.length}`);
  
  return lines.join('\n');
}

/**
 * Commit and push changes to GitHub
 */
async function commitAndPush(message: string): Promise<void> {
  const projectRoot = path.resolve(process.cwd());
  
  try {
    // Configure git if not already configured
    try {
      await execAsync('git config user.name', { cwd: projectRoot });
    } catch {
      await execAsync('git config user.name "Sports Bar TV Controller"', { cwd: projectRoot });
      await execAsync('git config user.email "system@sportsbar.local"', { cwd: projectRoot });
    }
    
    // Add TODO_LIST.md
    await execAsync('git add TODO_LIST.md', { cwd: projectRoot });
    
    // Check if there are changes to commit
    const { stdout: status } = await execAsync('git status --porcelain', { cwd: projectRoot });
    
    if (status.trim()) {
      // Commit
      await execAsync(`git commit -m "${message}"`, { cwd: projectRoot });
      
      // Push
      await execAsync('git push origin main', { cwd: projectRoot });
      
      logger.info(`‚úÖ Git sync successful: ${message}`);
    } else {
      logger.info('‚ÑπÔ∏è No changes to commit');
    }
  } catch (error) {
    logger.error('‚ùå Git sync error:', error);
    throw error;
  }
}

/**
 * Sync TODOs to GitHub by updating TODO_LIST.md and committing
 */
export async function syncTodosToGitHub(commitMessage: string): Promise<void> {
  try {
    // Generate markdown content
    const markdown = await generateTodoListMarkdown();
    
    // Write to TODO_LIST.md
    const todoListPath = path.resolve(process.cwd(), 'TODO_LIST.md');
    await fs.writeFile(todoListPath, markdown, 'utf-8');
    
    logger.info('‚úÖ TODO_LIST.md updated');
    
    // Commit and push
    await commitAndPush(commitMessage);
  } catch (error) {
    logger.error('‚ùå Error syncing TODOs to GitHub:', error);
    throw error;
  }
}
