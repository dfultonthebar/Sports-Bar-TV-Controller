/**
 * Memory Bank Context Generator
 * Generates markdown summaries of project state
 */

import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs/promises';
import path from 'path';
import { logger } from '@sports-bar/logger';
import type { FileChangeEvent } from './file-watcher';

const execAsync = promisify(exec);

export interface ProjectContext {
  timestamp: Date;
  branch: string;
  lastCommit: {
    hash: string;
    message: string;
    author: string;
    date: string;
  };
  modifiedFiles: string[];
  untrackedFiles: string[];
  stagedFiles: string[];
  recentChanges: FileChangeEvent[];
  systemState: {
    pm2Status?: string;
    databasePath: string;
    port: number;
    nodeVersion: string;
  };
  fileTree: string;
  quickResume: string[];
}

export class ContextGenerator {
  private projectRoot: string;

  constructor(projectRoot: string = process.cwd()) {
    this.projectRoot = projectRoot;
  }

  /**
   * Generate complete project context
   */
  async generateContext(recentChanges: FileChangeEvent[] = []): Promise<ProjectContext> {
    logger.info('Generating project context');

    try {
      const [
        branch,
        lastCommit,
        gitStatus,
        systemState,
        fileTree,
      ] = await Promise.all([
        this.getCurrentBranch(),
        this.getLastCommit(),
        this.getGitStatus(),
        this.getSystemState(),
        this.generateFileTree(),
      ]);

      const context: ProjectContext = {
        timestamp: new Date(),
        branch,
        lastCommit,
        modifiedFiles: gitStatus.modified,
        untrackedFiles: gitStatus.untracked,
        stagedFiles: gitStatus.staged,
        recentChanges,
        systemState,
        fileTree,
        quickResume: this.generateQuickResume(gitStatus, systemState),
      };

      logger.info('Project context generated successfully');
      return context;
    } catch (error) {
      logger.error('Failed to generate project context:', { error });
      throw error;
    }
  }

  /**
   * Convert context to markdown format
   */
  async contextToMarkdown(context: ProjectContext): Promise<string> {
    const lines: string[] = [];

    // Header
    lines.push(`# Project Context - ${context.timestamp.toISOString()}`);
    lines.push('');
    lines.push(`*Generated by Memory Bank on ${context.timestamp.toLocaleString()}*`);
    lines.push('');

    // Current Status
    lines.push('## Current Status');
    lines.push('');
    lines.push(`- **Branch:** \`${context.branch}\``);
    lines.push(`- **Last Commit:** ${context.lastCommit.hash.substring(0, 7)} - ${context.lastCommit.message}`);
    lines.push(`- **Author:** ${context.lastCommit.author}`);
    lines.push(`- **Commit Date:** ${context.lastCommit.date}`);
    lines.push(`- **Modified Files:** ${context.modifiedFiles.length}`);
    lines.push(`- **Staged Files:** ${context.stagedFiles.length}`);
    lines.push(`- **Untracked Files:** ${context.untrackedFiles.length}`);
    lines.push('');

    // Recent Changes
    if (context.recentChanges.length > 0) {
      lines.push('## Recent Changes');
      lines.push('');
      const changesByType = {
        add: context.recentChanges.filter(c => c.type === 'add'),
        change: context.recentChanges.filter(c => c.type === 'change'),
        unlink: context.recentChanges.filter(c => c.type === 'unlink'),
      };

      if (changesByType.add.length > 0) {
        lines.push('### Added Files');
        changesByType.add.forEach(change => {
          lines.push(`- \`${change.path}\``);
        });
        lines.push('');
      }

      if (changesByType.change.length > 0) {
        lines.push('### Modified Files');
        changesByType.change.forEach(change => {
          lines.push(`- \`${change.path}\``);
        });
        lines.push('');
      }

      if (changesByType.unlink.length > 0) {
        lines.push('### Deleted Files');
        changesByType.unlink.forEach(change => {
          lines.push(`- \`${change.path}\``);
        });
        lines.push('');
      }
    }

    // Git Status
    if (context.stagedFiles.length > 0) {
      lines.push('## Staged Files');
      lines.push('');
      context.stagedFiles.forEach(file => {
        lines.push(`- \`${file}\``);
      });
      lines.push('');
    }

    if (context.modifiedFiles.length > 0) {
      lines.push('## Modified Files (Unstaged)');
      lines.push('');
      context.modifiedFiles.forEach(file => {
        lines.push(`- \`${file}\``);
      });
      lines.push('');
    }

    if (context.untrackedFiles.length > 0) {
      lines.push('## Untracked Files');
      lines.push('');
      context.untrackedFiles.slice(0, 20).forEach(file => {
        lines.push(`- \`${file}\``);
      });
      if (context.untrackedFiles.length > 20) {
        lines.push(`- *...and ${context.untrackedFiles.length - 20} more*`);
      }
      lines.push('');
    }

    // System State
    lines.push('## System State');
    lines.push('');
    lines.push(`- **Database:** \`${context.systemState.databasePath}\``);
    lines.push(`- **Port:** ${context.systemState.port}`);
    lines.push(`- **Node Version:** ${context.systemState.nodeVersion}`);
    if (context.systemState.pm2Status) {
      lines.push(`- **PM2 Status:** ${context.systemState.pm2Status}`);
    }
    lines.push('');

    // File Tree
    lines.push('## Key Project Structure');
    lines.push('');
    lines.push('```');
    lines.push(context.fileTree);
    lines.push('```');
    lines.push('');

    // Quick Resume
    lines.push('## Quick Resume');
    lines.push('');
    lines.push('Run these commands to get back to work:');
    lines.push('');
    lines.push('```bash');
    context.quickResume.forEach(command => {
      lines.push(command);
    });
    lines.push('```');
    lines.push('');

    // Footer
    lines.push('---');
    lines.push('');
    lines.push('*This context snapshot was automatically generated by the Memory Bank system.*');
    lines.push('*To restore this context, run: `npm run memory:restore`*');

    return lines.join('\n');
  }

  /**
   * Get current git branch
   */
  private async getCurrentBranch(): Promise<string> {
    try {
      const { stdout } = await execAsync('git rev-parse --abbrev-ref HEAD', {
        cwd: this.projectRoot,
      });
      return stdout.trim();
    } catch (error) {
      logger.warn('Failed to get current branch:', { error });
      return 'unknown';
    }
  }

  /**
   * Get last commit information
   */
  private async getLastCommit(): Promise<ProjectContext['lastCommit']> {
    try {
      const { stdout } = await execAsync(
        'git log -1 --format="%H|%s|%an|%ai"',
        { cwd: this.projectRoot }
      );
      const [hash, message, author, date] = stdout.trim().split('|');
      return { hash, message, author, date };
    } catch (error) {
      logger.warn('Failed to get last commit:', { error });
      return {
        hash: 'unknown',
        message: 'No commits',
        author: 'unknown',
        date: new Date().toISOString(),
      };
    }
  }

  /**
   * Get git status (modified, untracked, staged files)
   */
  private async getGitStatus(): Promise<{
    modified: string[];
    untracked: string[];
    staged: string[];
  }> {
    try {
      const { stdout } = await execAsync('git status --porcelain', {
        cwd: this.projectRoot,
      });

      const modified: string[] = [];
      const untracked: string[] = [];
      const staged: string[] = [];

      stdout.split('\n').forEach(line => {
        if (!line.trim()) return;

        const status = line.substring(0, 2);
        const file = line.substring(3);

        if (status.includes('M') && status[0] !== ' ') {
          staged.push(file);
        } else if (status.includes('M')) {
          modified.push(file);
        } else if (status.includes('?')) {
          untracked.push(file);
        } else if (status.includes('A')) {
          staged.push(file);
        }
      });

      return { modified, untracked, staged };
    } catch (error) {
      logger.warn('Failed to get git status:', { error });
      return { modified: [], untracked: [], staged: [] };
    }
  }

  /**
   * Get system state information
   */
  private async getSystemState(): Promise<ProjectContext['systemState']> {
    const state: ProjectContext['systemState'] = {
      databasePath: '/home/ubuntu/sports-bar-data/production.db',
      port: 3001,
      nodeVersion: process.version,
    };

    try {
      // Try to get PM2 status
      const { stdout } = await execAsync('pm2 jlist', {
        cwd: this.projectRoot,
      });
      const processes = JSON.parse(stdout);
      const app = processes.find((p: any) => p.name === 'sports-bar-tv');
      if (app) {
        state.pm2Status = app.pm2_env.status;
      }
    } catch (error) {
      logger.debug('PM2 not available or not running');
    }

    return state;
  }

  /**
   * Generate file tree of key directories
   */
  private async generateFileTree(): Promise<string> {
    const tree: string[] = [];
    tree.push('Sports-Bar-TV-Controller/');

    const keyDirs = ['src/', 'docs/', 'scripts/', 'tests/', 'data/'];

    for (const dir of keyDirs) {
      const fullPath = path.join(this.projectRoot, dir);
      try {
        await fs.access(fullPath);
        tree.push(`├── ${dir}`);

        // Add some key subdirectories
        if (dir === 'src/') {
          tree.push('│   ├── app/');
          tree.push('│   ├── components/');
          tree.push('│   ├── lib/');
          tree.push('│   └── db/');
        }
      } catch {
        // Directory doesn't exist, skip
      }
    }

    // Add key files
    const keyFiles = [
      'package.json',
      'next.config.js',
      'ecosystem.config.js',
      'drizzle.config.ts',
    ];

    for (const file of keyFiles) {
      const fullPath = path.join(this.projectRoot, file);
      try {
        await fs.access(fullPath);
        tree.push(`├── ${file}`);
      } catch {
        // File doesn't exist, skip
      }
    }

    return tree.join('\n');
  }

  /**
   * Generate quick resume commands
   */
  private generateQuickResume(
    gitStatus: { modified: string[]; staged: string[]; untracked: string[] },
    systemState: ProjectContext['systemState']
  ): string[] {
    const commands: string[] = [];

    commands.push('# Navigate to project');
    commands.push('cd /home/ubuntu/Sports-Bar-TV-Controller');
    commands.push('');

    if (systemState.pm2Status !== 'online') {
      commands.push('# Start the application');
      commands.push('pm2 start ecosystem.config.js');
      commands.push('');
    }

    commands.push('# Check application status');
    commands.push('pm2 status');
    commands.push('pm2 logs sports-bar-tv --lines 20');
    commands.push('');

    if (gitStatus.modified.length > 0 || gitStatus.staged.length > 0) {
      commands.push('# Review uncommitted changes');
      commands.push('git status');
      commands.push('git diff');
      commands.push('');
    }

    commands.push('# Development commands');
    commands.push('npm run dev          # Start development server');
    commands.push('npm run build        # Build for production');
    commands.push('npm test             # Run tests');
    commands.push('npm run db:studio    # Open database studio');

    return commands;
  }
}

// Export singleton
let contextGeneratorInstance: ContextGenerator | null = null;

export function getContextGenerator(projectRoot?: string): ContextGenerator {
  if (!contextGeneratorInstance) {
    contextGeneratorInstance = new ContextGenerator(projectRoot);
  }
  return contextGeneratorInstance;
}
